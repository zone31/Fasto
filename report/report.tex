\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{fancyhdr, amsmath, amssymb, comment, caption, placeins, subfigure,
    fixltx2e, changepage, listings, courier, soul, hyperref, geometry,
    enumerate, dsfont, listings, enumitem}

% \author{
%     \Large{Magnus N\o rskov Stavngaard, Mark Jan Jacobi and Christian
%         Salb\ae k} \\
%     \texttt{magnus@stavngaard.dk, mark@jacobi.pm and chr.salbaek@gmail.com} \\
% }

\author{
    \Large{Magnus N\o rskov Stavngaard \& Mark Jan Jacobi \& Christian
        Salb\ae k} \\
    \texttt{magnus@stavngaard.dk, mark@jacobi.pm and chr.salbaek@gmail.com} \\
}

\title{
    \vspace{3cm}
    \Huge{Compiler Design} \\
    \Large{Compiler for the Fasto Programming Language}
}

\pagestyle{fancy}
\lhead{Magnus N. S. Mark J. J. Christian S.}
\chead{\date{\today}}
\rhead{University of Copenhagen}
% \lfoot{}
% \cfoot{}
% \rfoot{}

% Change indent length of paragraph not after a header.
\setlength{\parindent}{0cm}

% Remove page numbering in the beginning
\pagenumbering{gobble}

\begin{document}

    %% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
    %% `natbio-farve` to use SCIENCE's new colors and logo.
    \AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]
        {include/ku-farve}}}
    \AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]
        {include/ku-farve}}}

    %% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
    \AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

    \clearpage
    \maketitle
    \thispagestyle{empty}

    \newpage

    \pagenumbering{arabic} % Arabic page numbers (and reset to 1)

    \section{Task 1 - Warmup}
    In task 1 we were asked to implement the boolean operators \texttt{\&\&},
    \texttt{||} and \texttt{not}, the boolean constants true and false, integer
    multiplication, integer division and integer negation. \\

    We will go through in detail the implementation of integer division and
    multiplication and then skip rather quickly over the implementation of the
    rest of the operators only describing what is different from multiplication
    and division as the operations is implemented very similar.

    \subsection{Integer Multiplication and Division}
    We started by implementing integer multiplication and division in the Lexer.
    We created a new rule for the star and division operator that created tokens
    and passed the tokens to the parser.

    \begin{lstlisting}[basicstyle=\small]
| `*`   { Parser.TIMES    (getPos lexbuf) }
| `/`   { Parser.DIVIDE   (getPos lexbuf) }
    \end{lstlisting}

    In the parser we added the tokens where addition and subtraction was already
    defined, as integer multiplication and division has allot in common with
    addition and subtraction.  Integer multiplication and division carries two
    integers corresponding to a position in the code.

    \begin{lstlisting}[basicstyle=\small]
%token <(int*int)> PLUS MINUS TIMES DIVIDE DEQ EQ LTH BOOLAND BOOLOR NOT NEG
    \end{lstlisting}

    We also declare both times and divide as left associative operators with
    greater precedence than addition and subtraction.

    \begin{lstlisting}[basicstyle=\small]
%left BOOLOR
%left BOOLAND
%left NOT
%left DEQ LTH
%left PLUS MINUS
%left TIMES
%left DIVIDE
%left NEG
    \end{lstlisting}

    We then defined that an expression could consist of an expression followed
    by a multiplication or division followed by an expression.  And that this
    correspond to \texttt{Times} and \texttt{Divide} in the Fasto language
    definition.

    \begin{lstlisting}[basicstyle=\small]
Exp :     NUM                 { Constant (IntVal (#1 $1), #2 $1) }
        | CHARLIT             { Constant (CharVal (#1 $1), #2 $1) }

        (...)

        | Exp TIMES Exp       { Times($1, $3, $2) }
        | Exp DIVIDE Exp      { Divide($1, $3, $2) }

        (...)
    \end{lstlisting}

    In the interpreter we implemented cases for \texttt{Times} and
    \texttt{Divide} in the \texttt{evalExpr} function.

    \begin{lstlisting}[basicstyle=\small]
| evalExp ( Times(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op *, res1, res2, pos)
      end

| evalExp ( Divide(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op Int.quot, res1, res2, pos)
      end
    \end{lstlisting}

    Our cases evaluate recursively the expressions to the left and right of the
    operator and then calls \texttt{evalBinopNum} with the appropriate operator
    and the results from evaluating the lefthand and the righthand side of the
    expression. \\

    We then implemented the operators in the typechecker.  Our cases call a
    helper function \texttt{checkBinOp} that takes a position, an expected type,
    and two expressions and check that the two expressions have the type of the
    expected type.  If the types match the types is returned with
    \textit{typedecorated} versions of the expressions, if the types doesn't
    match an error is raised. \\
    We then simply return the same operation, now with a return type.

    \begin{lstlisting}[basicstyle=\small]
| In.Times (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Times (e1_dec, e2_dec, pos))
     end

| In.Divide (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Divide (e1_dec, e2_dec, pos))
     end
    \end{lstlisting}

    We can now finally implement the operators in the code generator.  Here we
    create two temporary variables \texttt{t1} and \texttt{t2} to hold the
    values of the expression on either side of the operator.  We then call the
    function \texttt{compileExp} recursively with these names to get the machine
    code for the expression on either side of the operator.  Then we just simply
    return a list of first the code to compute the left hand side of the
    operator, then the right hand side, and then we apply the MIPS commands
    \texttt{MUL} and \texttt{DIV} to the two \textit{subresults} and save the
    result in \texttt{place}.

    \begin{lstlisting}[basicstyle=\small]
| Times (e1, e2, pos) =>
    let val t1 = newName "times_L"
        val t2 = newName "times_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.MUL (place, t1, t2)]
    end
| Divide (e1, e2, pos) =>
    let val t1 = newName "divide_L"
        val t2 = newName "divide_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.DIV (place, t1, t2)]
    end
    \end{lstlisting}

    \subsection{Boolean Operators}
    We started by implementing the boolean operators in the lexer in a very
    similar way that we implemented multiplication and division.  In the parser,
    we made sure that the boolean operators were defined as having a lower
    precedence than the arithmetic operators, so that an expression like,

    \begin{lstlisting}[basicstyle=\small]
        2 + 4 == 6 || 5 + 8 == 10 && 8 < 10
    \end{lstlisting}

    is evaluated like,

    \begin{lstlisting}[basicstyle=\small]
        (2 + 4 == 6) || ((5 + 8 == 10) && (8 < 10)).
    \end{lstlisting}

    Notice that the \texttt{\&\&} operator is also evaluated before the
    \texttt{||} operator. \\

    After this we implemented the operators in the interpreter.  Here we created
    two new functions \texttt{evalAnd} and \texttt{evalOr} which evaluated and
    and or operations and returned an error if the expression to the left or
    right of the operators didn't return a boolean value.

    \begin{lstlisting}[basicstyle=\small]
fun evalAnd (BoolVal e1, BoolVal e2, pos) = BoolVal (e1 andalso e2)
  | evalAnd (e1, e2, pos) = raise Error("&& expects bool operands", pos)

fun evalOr (BoolVal e1, BoolVal e2, pos) = BoolVal (e1 orelse e2)
  | evalOr (e1, e2, pos) = raise Error("|| expects bool operands", pos)
    \end{lstlisting}

    We evaluated the expressions to the left and right of the operator and then
    called the helper functions afterwards. \\

    In the code generator it was required that we implemented the boolean
    operators to be short-circuiting so that the right hand side of an and only
    evaluates if the left hand side is true. Similarly the right hand side of an
    or evaluates only if the left hand side is false.  We did this with the MIPS
    assembly code,

    \begin{lstlisting}[basicstyle=\small]
;; Code computing the left hand side of an and, and saving result to $t1

beq $t1, $zero, False

;; Code computing the right hand side of an and, and saving the result to $t2

beq $t2, $zero, False
li  $s1, 1 ;; Assuming the result should be saved to $s1
j   End

False:
    li  $s1, 0 ;; Assuming the result should be saved to $s2

End:
    \end{lstlisting}

    It can be seen that if the first part of an and return false i.e. the
    result register contains 0, we simply skip over the execution of the right
    hand side and jump strait to False.  We did something similar for or's.

    \section{Task 2 - Implement \texttt{filter} and \texttt{scan}}
    \subsection{Typerules}
    The typerules for \texttt{filter} and \texttt{scan} have been based on the
    already existing typerules for \texttt{map} and \texttt{reduce}. They are as
    follows: \\

    \texttt{filter}: ($\alpha \rightarrow$ bool) $\ast$ $[\alpha]$ $\rightarrow$
    $[\alpha]$, typerule for \texttt{filter(f, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item compute t, the type of x and check that $\text{t} =
            [\text{t}_\text{e}]$ for some type $\text{t}_\text{e}$
        \item get f's signature from \texttt{ftable}. \texttt{IF} f does not
            receive exactly one argument \texttt{THEN} return \texttt{error()}
            \texttt{ELSE} $\text{f: t}_{\text{in}} \rightarrow
            \text{t}_{\text{out}}$ for some types $\text{t}_{\text{in}}$ and
            $\text{t}_{\text{out}}$.
        \item \texttt{IF} $\text{t}_{\text{in}} = \text{t}_\text{e}$
            \texttt{AND} $\text{t}_{\text{out}} = \texttt{bool}$ \texttt{THEN
            filter(f, x) ELSE error()}.
    \end{itemize}

    \texttt{scan}: ($\alpha \ast \alpha \rightarrow \alpha$) $\ast$ $\alpha$
    $\ast$ [$\alpha$] $\rightarrow$ [$\alpha$], typerule for
    \texttt{scan(f, e, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item Compute t, the type of e and $\text{t}_\text{x}$, the type of x
            and check that:
        	\begin{enumerate}[noitemsep]
        	   \item f: (t $\ast$ t) $\rightarrow$ t
        	   \item $\text{t}_\text{x} = [\text{t}]$
    		\end{enumerate}
        \item If so then \texttt{scan(f, e, x)}
    \end{itemize}

    \section{$\lambda$-expressions in SOAC's}
    We implemented lambda functions in the lexer by creating a keyword
    \texttt{fn} corresponding to a \texttt{LAMBDA} in the parser.  We also
    created a token for the special equals symbols used in lambda expressions
    (=$>$).  We called this token \texttt{LAMBDAEQ}.  We then implemented lambdas
    in the parser.  We did this by observing that the \texttt{map} function in
    the parser is defined as,

    \begin{lstlisting}[basicstyle=\small]
| MAP LPAR FunArg COMMA Exp RPAR { Map ($3, $5, (), (), $1) }
    \end{lstlisting}

    meaning that the lambda is supposed to passed as a \texttt{FunArg}.  We then
    looked at the declaration of a FunArg,

    \begin{lstlisting}[basicstyle=\small]
FunArg : ID { FunName (#1 $1) },
    \end{lstlisting}

    and added to this definition a case for a lambda function.  In Fasto a
    \texttt{FunArg} is defined as,

    \begin{lstlisting}[basicstyle=\small]
and FunArg = Lambda of Type * Param list * Exp * pos
           | FunName of string.
    \end{lstlisting}

    We then just took the syntax of a lambda and translated that to a list of
    tokens.  Then we pattern matched on that expression and transfered the
    values needed by the lambda in Fasto.

    \begin{lstlisting}[basicstyle=\small]
FunArg : ID { FunName (#1 $1) }
     |   LAMBDA Type LPAR Params RPAR LAMBDAEQ Exp { Lambda ($2, $4, $7, $1) }
    \end{lstlisting}

    We implemented lambdas in the interpreter by changing the way function
    arguments are evaluated.  We could do this as it is an invariant of the
    Fasto programming language that lambdas can only be used in Second Order
    Array Constructors (SOAC's).  We simply matched a case where
    \texttt{evalFunArg} is called with a lambda instead of a function name.  We
    then use this lambda to construct a function definition with the generic
    name \textit{lambda}.  We then call \texttt{callFunWithVtable} with this
    function declaration and the vtable passed to the function, this means that
    we keep the binding between local variable names and their values and the
    lambda can use these variables.  The function returns an anonymous function
    in sml that takes an argument list and applies the lambda to those
    arguments.

    \begin{lstlisting}[basicstyle=\small]
and evalFunArg (FunName fid, vtab, ftab, callpos) =
    let
      val fexp = SymTab.lookup fid ftab
    in
      case fexp of
        NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
      | SOME f => (fn aargs => callFun(f, aargs, ftab, callpos), getFunRTP f)
    end
  | evalFunArg (Lambda (tp, paralist, exp, pos), vtab, ftab, pcall) =
    let val fexp = FunDec ("lambda", tp, paralist, exp, pos)
    in (fn aargs => callFunWithVtable(fexp, aargs, vtab, ftab, pcall), tp)
    end
    \end{lstlisting}

\end{document}
