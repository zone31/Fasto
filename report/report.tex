\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{fancyhdr, amsmath, amssymb, comment, caption, placeins, subfigure,
    fixltx2e, changepage, listings, courier, soul, hyperref, geometry,
    enumerate, dsfont, listings, enumitem}
    \usepackage[T1]{fontenc}

\author{\Large{Magnus N\o rskov Stavngaard} \\
		\texttt{magnus@stavngaard.dk}
		\\\\
		\Large{Mark Jan Jacobi} \\
        \texttt{mark@jacobi.pm}
		 \\\\
		\Large{Christian Salb\ae k} \\
		\texttt{chr.salbaek@gmail.com}
}

\title{
    \vspace{3cm}
    \Huge{Compiler Design} \\
    \Large{Compiler for the Fasto Programming Language}
}

\pagestyle{fancy}
\lhead{\small{Magnus N. S. Mark J. J. Christian S.}}
\chead{\date{\today}}
\rhead{University of Copenhagen}
% \lfoot{}
% \cfoot{}
% \rfoot{}

% Change indent length of paragraph not after a header.
\setlength{\parindent}{0cm}

% Remove page numbering in the beginning
\pagenumbering{gobble}

\begin{document}

    %% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
    %% `natbio-farve` to use SCIENCE's new colors and logo.
    \AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]
        {include/ku-farve}}}
    \AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]
        {include/ku-farve}}}

    %% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
    \AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

    \clearpage
    \maketitle
    \thispagestyle{empty}

    \newpage

    \tableofcontents

    \newpage

    \pagenumbering{arabic} % Arabic page numbers (and reset to 1)

    \section{Task 1 - Warmup}
    In task 1 we were asked to implement the boolean operators \texttt{\&\&},
    \texttt{||} and \texttt{not}, the boolean constants true and false, integer
    multiplication, integer division and integer negation. \\

    We will go through in detail the implementation of integer division and
    multiplication and then skip rather quickly over the implementation of the
    rest of the operators only describing what is different from multiplication
    and division as the operations is implemented very similar.

    \subsection{Integer Multiplication and Division}
    We started by implementing integer multiplication and division in the Lexer.
    We created a new rule for the star and division operator that created tokens
    and passed the tokens to the parser.

    \begin{lstlisting}[basicstyle=\small]
| `*`   { Parser.TIMES    (getPos lexbuf) }
| `/`   { Parser.DIVIDE   (getPos lexbuf) }
    \end{lstlisting}

    In the parser we added the tokens where addition and subtraction was already
    defined, as integer multiplication and division has allot in common with
    addition and subtraction.  Integer multiplication and division carries two
    integers corresponding to a position in the code.

    \begin{lstlisting}[basicstyle=\small]
%token <(int*int)> PLUS MINUS TIMES DIVIDE DEQ EQ LTH BOOLAND BOOLOR NOT NEG
    \end{lstlisting}

    We also declare both times and divide as left associative operators with
    greater precedence than addition and subtraction.

    \begin{lstlisting}[basicstyle=\small]
%left BOOLOR
%left BOOLAND
%left NOT
%left DEQ LTH
%left PLUS MINUS
%left TIMES DIVIDE
%left NEG
    \end{lstlisting}

    We then defined that an expression could consist of an expression followed
    by a multiplication or division followed by an expression.  And that this
    correspond to \texttt{Times} and \texttt{Divide} in the Fasto language
    definition.

    \begin{lstlisting}[basicstyle=\small]
Exp :     NUM                 { Constant (IntVal (#1 $1), #2 $1) }
        | CHARLIT             { Constant (CharVal (#1 $1), #2 $1) }

        (...)

        | Exp TIMES Exp       { Times($1, $3, $2) }
        | Exp DIVIDE Exp      { Divide($1, $3, $2) }

        (...)
    \end{lstlisting}

    In the interpreter we implemented cases for \texttt{Times} and
    \texttt{Divide} in the \texttt{evalExpr} function.

    \begin{lstlisting}[basicstyle=\small]
| evalExp ( Times(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op *, res1, res2, pos)
      end

| evalExp ( Divide(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op Int.quot, res1, res2, pos)
      end
    \end{lstlisting}

    Our cases evaluate recursively the expressions to the left and right of the
    operator and then calls \texttt{evalBinopNum} with the appropriate operator
    and the results from evaluating the lefthand and the righthand side of the
    expression. \\

    We then implemented the operators in the typechecker.  Our cases call a
    helper function \texttt{checkBinOp} that takes a position, an expected type,
    and two expressions and check that the two expressions have the type of the
    expected type.  If the types match the types is returned with
    \textit{typedecorated} versions of the expressions, if the types doesn't
    match an error is raised. \\
    We then simply return the same operation, now with a return type.

    \begin{lstlisting}[basicstyle=\small]
| In.Times (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Times (e1_dec, e2_dec, pos))
     end

| In.Divide (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Divide (e1_dec, e2_dec, pos))
     end
    \end{lstlisting}

    We can now finally implement the operators in the code generator.  Here we
    create two temporary variables \texttt{t1} and \texttt{t2} to hold the
    values of the expression on either side of the operator.  We then call the
    function \texttt{compileExp} recursively with these names to get the machine
    code for the expression on either side of the operator.  Then we just simply
    return a list of first the code to compute the left hand side of the
    operator, then the right hand side, and then we apply the MIPS commands
    \texttt{MUL} and \texttt{DIV} to the two \textit{subresults} and save the
    result in \texttt{place}.

    \begin{lstlisting}[basicstyle=\small]
| Times (e1, e2, pos) =>
    let val t1 = newName "times_L"
        val t2 = newName "times_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.MUL (place, t1, t2)]
    end
| Divide (e1, e2, pos) =>
    let val t1 = newName "divide_L"
        val t2 = newName "divide_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.DIV (place, t1, t2)]
    end
    \end{lstlisting}

    \subsection{Boolean Operators}
    We started by implementing the boolean operators in the lexer in a very
    similar way that we implemented multiplication and division.  In the parser,
    we made sure that the boolean operators were defined as having a lower
    precedence than the arithmetic operators, so that an expression like,

    \begin{lstlisting}[basicstyle=\small]
        2 + 4 == 6 || 5 + 8 == 10 && 8 < 10
    \end{lstlisting}

    is evaluated like,

    \begin{lstlisting}[basicstyle=\small]
        ((2 + 4) == 6) || (((5 + 8) == 10) && (8 < 10)).
    \end{lstlisting}

    Notice that the \texttt{\&\&} operator is also evaluated before the
    \texttt{||} operator. \\

    After this we implemented the operators in the interpreter.  Here we created
    a case for \texttt{and} and a case for \texttt{or}.  We had to implement
    them as short circuited which means that the right hand side of an
    \texttt{and} should only be evaluated if the left hand side is true.
    Similarly for \texttt{or} the right hand side should only be evaluated if
    the left hand side is false (The or implementation can be seen in appendix
    \ref{interpreter_and_and_or}.

    \begin{lstlisting}[basicstyle=\small]
| evalExp ( And(e1, e2, pos), vtab, ftab ) =
      let val r1 = evalExp(e1, vtab, ftab)
      in case r1 of
         BoolVal b1 => if b1 then
                        let val r2 = evalExp(e2, vtab, ftab)
                        in case r2 of
                           BoolVal b2 => BoolVal b2
                         | otherwise  => raise Error ("And expect boolval", pos)
                        end
                       else BoolVal b1
       | otherwise  => raise Error ("And expect boolval", pos)
      end

    \end{lstlisting}

    We first evaluate the lefthand expression, if that is true we evaluate the
    right hand expression, if that is also true we return True otherwise we
    return false.  If either of the expressions isn't a BoolVal, we report an
    error. \\

    In the code generator it was also required that we implemented the boolean
    operators to be short-circuiting so that the right hand side of an
    \texttt{and} only evaluates if the left hand side is true.  Similarly the
    right hand side of an \texttt{or} evaluates only if the left hand side is
    false.  We did this with the MIPS assembly code,

    \begin{lstlisting}[basicstyle=\small]
$t1 = compile e1

beq $t1, $zero, False

$t2 = compile e2

beq $t2, $zero, False
li  $s1, 1 ;; Assuming the result should be saved to $s1
j   End

False:
    li  $s1, 0 ;; Assuming the result should be saved to $s2

End:
    \end{lstlisting}

    It can be seen that if the first part of an \texttt{and} return false i.e.
    the result register contains 0, we simply skip over the execution of the
    right hand side and jump strait to False.  We did something similar for
    \texttt{or}'s.  The Standard ML code generating the MIPS assembly for both
    \texttt{and} and \texttt{or} can be seen in appendix
    \ref{code_gen_and_and_or}.

    \subsection{Boolean Negation}
    In the lexer we implemented the operator for boolean negation \texttt{not}
    as a keyword.  We did this because \texttt{not} is a valid variable name and
    would pass the rule,

    \begin{lstlisting}[basicstyle=\small]
| [`a`-`z` `A`-`Z`] [`a`-`z` `A`-`Z` `0`-`9` `_`]*
                      { keyword (getLexeme lexbuf,getPos lexbuf) }.
    \end{lstlisting}

    If we didn't implement a keyword, \texttt{not} would simply fall through and
    go in the case,

    \begin{lstlisting}
| _              => Parser.ID (s, pos)
    \end{lstlisting}

    in the \texttt{keyword} function.  The implemented keyword goes to a
    \texttt{Parser.NOT} in the parser and carries only the position.

    \begin{lstlisting}[basicstyle=\small]
fun keyword (s, pos) =
    case s of
         "if"           => Parser.IF pos
       | "then"         => Parser.THEN pos

       (...)

       | "not"          => Parser.NOT pos
       | "fn"           => Parser.LAMBDA pos
       | _              => Parser.ID (s, pos)
}
    \end{lstlisting}

    In the interpreter \texttt{not} is implemented simply by evaluating the
    expression after the \texttt{not}.  If that expression results in a true,
    false is returned, if it results in a false, true is returned and otherwise
    an error is reported.  The code can be seen in appendix
    \ref{interpreter_not}. \\

    \texttt{not} is implemented in the code generator as a branch operation.  If
    \texttt{not} is applied to true 3 operations are performed, if it is applied
    to false only 2 operations are performed.  The code generating MIPS assembly
    can be found in appendix \ref{code_gen_not}.

    \subsection{Integer Negation}
    Integer negation has been implemented two places in the lexer.  For integer
    constants which is negated the negated value is simply created on
    compiletime.  This is done by the rule,

    \begin{lstlisting}[basicstyle=\small]
| [`0`-`9`]+ | "~" [`0`-`9`]+ { case Int.fromString (getLexeme lexbuf) of
                             NONE   => lexerError lexbuf "Bad integer"
                           | SOME i => Parser.NUM (i, getPos lexbuf) }
    \end{lstlisting}

    which says that a number or a tilde followed by a one or more numbers is a
    Parser.NUM in the parser and the integer value is carried with it. \\

    If a tilde is not followed by a number for example in,

    \begin{lstlisting}
~(2 + 4) - ~(2 - ~f(3))
    \end{lstlisting}

    the negation is caught by the rule,

    \begin{lstlisting}
| "~"                 { Parser.NEG      (getPos lexbuf) }
    \end{lstlisting}

    In the code generator the negations is performed as a exclusive or and an
    addition.

    \begin{lstlisting}[basicstyle=\small]
| Negate (e, pos) =>
    let val negThis  = newName "negThis"
        val code     = compileExp e vtable negThis
        val negation =
            [Mips.XORI(negThis,negThis,"-1")] @ [Mips.ADDI (place,negThis,"1")]
    in code @ negation
    end
    \end{lstlisting}

    This works because computers use two's complement to express numbers.  In
    two's complement the negation of a number is computed by flipping all bits
    in the number and adding 1.  We flip all bits by exclusive or'ring with -1,
    the binary value of -1 is 1111 1111.  Therefore all the places where there
    was 0 in the original number there will now be 1 and where there were 1
    there will now be 0.  After that we simply add 1 with \texttt{addi} and save
    the result to place.

    \subsection{Boolean Literals}
    The boolean literals is implemented in the lexer as a keyword that carries a
    boolean value to the parser.  The implementation of boolean literals in all
    compiler phases can be found in appendix \ref{boolean_implementation}.

    \subsection{Test}
    \begin{tabular}{|l|l|}
        \hline
        \textbf{Test name} & \textbf{Test description}                        \\
        \hline
        andOr.fo           & Tests boolean operators and their precedence.    \\
        \hline
        and\_sc.fo         & Test if and is properly short circuited.         \\
        \hline
        boolCompare.fo     & Test boolean literals.                           \\
        \hline
        boolLit.fo         & Another test testing if boolean literals.        \\
        \hline
        intNegate.fo       & Test negation of integer values, only test the   \\
                           & simple case ~number not ~(number).  Operator     \\
                           & precedence is also tested.                       \\
        \hline
        muldivide.fo       & Tests the multiplication and division operators. \\
        \hline
        negate2.fo         & Again test simple integer negation.              \\
        \hline
        negate.fo          & Test the case where integer negation is followed \\
                           & by something other than a number.                \\
        \hline
        or\_sc.fo          & Test if or is short circuited.                   \\
        \hline
        tobeornottobe.fo   & Test precedence of boolean operators.            \\
        \hline
        and\_err.fo        & Test a typeerror for and.                        \\
        \hline
        div\_err.fo        & Test a typeerror for div.                        \\
        \hline
        mul\_err.fo        & Test a typeerror for mul.                        \\
        \hline
        neg\_err           & Test a typeerror for negation.                   \\
        \hline
        not\_err.fo        & Test a typeerror for not.                        \\
        \hline
        or\_err.fo         & Test a typeerror for or.                         \\
        \hline
    \end{tabular}

    All the test files are included in appendix \ref{task_1_tests}.

    \section{Task 2 - Implement \texttt{filter} and \texttt{scan}}
    \subsection{Typerules}
    The typerules for \texttt{filter} and \texttt{scan} have been based on the
    already existing typerules for \texttt{map} and \texttt{reduce}. They are as
    follows: \\

    \texttt{filter}: ($\alpha \rightarrow$ bool) $\ast$ $[\alpha]$ $\rightarrow$
    $[\alpha]$, typerule for \texttt{filter(f, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item compute t, the type of x and check that $\text{t} =
            [\text{t}_\text{e}]$ for some type $\text{t}_\text{e}$
        \item get f's signature from \texttt{ftable}. \texttt{IF} f does not
            receive exactly one argument \texttt{THEN} return \texttt{error()}
            \texttt{ELSE} $\text{f: t}_{\text{in}} \rightarrow
            \text{t}_{\text{out}}$ for some types $\text{t}_{\text{in}}$ and
            $\text{t}_{\text{out}}$.
        \item \texttt{IF} $\text{t}_{\text{in}} = \text{t}_\text{e}$
            \texttt{AND} $\text{t}_{\text{out}} = \texttt{bool}$ \texttt{THEN
            filter(f, x) ELSE error()}.
    \end{itemize}

    \texttt{scan}: ($\alpha \ast \alpha \rightarrow \alpha$) $\ast$ $\alpha$
    $\ast$ [$\alpha$] $\rightarrow$ [$\alpha$], typerule for
    \texttt{scan(f, e, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item Compute t, the type of e and $\text{t}_\text{x}$, the type of x
            and check that:
        	\begin{enumerate}[noitemsep]
        	   \item f: (t $\ast$ t) $\rightarrow$ t
        	   \item $\text{t}_\text{x} = [\text{t}]$
    		\end{enumerate}
        \item If so then \texttt{scan(f, e, x)}
    \end{itemize}

    \section{Task 3 - $\lambda$-expressions in SOAC's}
    \subsection{Lexer}
    We implemented lambda functions in the lexer by creating a keyword
    \texttt{fn} corresponding to a \texttt{LAMBDA} in the parser.  We also
    created a token for the special equals symbols used in lambda expressions
    (=$>$).  We called this token \texttt{LAMBDAEQ}.
    \subsection{Parser}
    We then implemented lambdas
    in the parser.  We did this by observing that the \texttt{map} function in
    the parser is defined as,

    \begin{lstlisting}[basicstyle=\small]
| MAP LPAR FunArg COMMA Exp RPAR { Map ($3, $5, (), (), $1) }
    \end{lstlisting}

    meaning that the lambda is supposed to passed as a \texttt{FunArg}.  We then
    looked at the declaration of a FunArg,

    \begin{lstlisting}[basicstyle=\small]
FunArg : ID { FunName (#1 $1) },
    \end{lstlisting}

    and added to this definition a case for a lambda function.  In Fasto a
    \texttt{FunArg} is defined as,

    \begin{lstlisting}[basicstyle=\small]
and FunArg = Lambda of Type * Param list * Exp * pos
           | FunName of string.
    \end{lstlisting}

    We then just took the syntax of a lambda and translated that to a list of
    tokens.  Then we pattern matched on that expression and transfered the
    values needed by the lambda in Fasto. Furthermore, Lambda expressions can also
    be called without arguments, therefore we need a case where the Params is non
    existant.

\lstinputlisting[
basicstyle=\footnotesize,
caption={Lambda in Parser.grm },
firstnumber=125,
linerange={125-127},
numbers=left]
{../fasto/src/Parser.grm}

\subsection{Interperter}
    We implemented lambdas in the interpreter by changing the way function
    arguments are evaluated.  We could do this as it is an invariant of the
    Fasto programming language that lambdas can only be used in Second Order
    Array Constructors (SOAC's).  We simply matched a case where
    \texttt{evalFunArg} is called with a lambda instead of a function name.  We
    then use this lambda to construct a function definition with the generic
    name \textit{lambda}.  We then call \texttt{callFunWithVtable} with this
    function declaration and the vtable passed to the function, this means that
    we keep the binding between local variable names and their values and the
    lambda can use these variables.  The function returns an anonymous function
    in sml that takes an argument list and applies the lambda to those
    arguments.

    \begin{lstlisting}[basicstyle=\small]
and evalFunArg (FunName fid, vtab, ftab, callpos) =
    let
      val fexp = SymTab.lookup fid ftab
    in
      case fexp of
        NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
      | SOME f => (fn aargs => callFun(f, aargs, ftab, callpos), getFunRTP f)
    end
  | evalFunArg (Lambda (tp, paralist, exp, pos), vtab, ftab, pcall) =
    let val fexp = FunDec ("lambda", tp, paralist, exp, pos)
    in (fn aargs => callFunWithVtable(fexp, aargs, vtab, ftab, pcall), tp)
    end
    \end{lstlisting}

\subsection{Code generator}
The code generation of lambda is a bit complex. The easiest way to explain how it works
is by a list, where each step is followed by the next, in chronological order.
\begin{enumerate}
  \item Remove type decleration from paralist.\\
  We remove the type decleration, beacuse it is not nessesary in the compilation state. This
  prepares us for a relation between the args in the call itself, and the parameters in the 
  lambda.
  \item Zip the newly generated list with args.\\
  This assings the args and the parameters in touples. We use a function called zipWith.
  It takes in 2 lists of 2 different types, and a function. Then it iterates over the 2 lists,
  and uses each element of the input lists in the input. Then the function return is stored in
  a new list.  
  \item Generate code that assigns input from args to the parameter list.\\
  We call zipWith again, but this time we generate a list of mips instructions. In this case
  move the assigned values into the correct registers, so the expression can use these
  \item Generate the local vTable, that contains the local variables.\\
  We now generate a new vTable, that contains the local variables only. We foldl over the zipped
  variable we declared in 2. This creates a SymTab structure witch makes it a valid vtable.
  \item Compile the expression from the lambda, via compileExp. It takes the local vTable,\\
  We can now compile the expression in the lambda. We have assigned the arguments, and made a 
  local vTable so the function can reassign variables such as x, without affecting the scope 
  outside the function.
  and a register to place its result.
  \item then we concatinate the code from 3 and 5, and returns this as a lambda call.
\end{enumerate}
The source code looks like this
 \begin{lstlisting}[language=ML,basicstyle=\footnotesize,caption={Lambda in CodeGen.sml },firstnumber=850,breaklines=false,numbers=left]
and applyFunArg (FunName s, args, vtable, place, pos) : Mips.Prog =
    let val tmp_reg = newName "tmp_reg"
    in  applyRegs(s, args, tmp_reg, pos) @ [Mips.MOVE(place, tmp_reg)] end
| applyFunArg (Lambda (tp, paralist, exp, _), args, vtable, place, pos) =
    let val lambda = newName "lambda"
        val argsparalist = map (fn Param(x,y) => x) paralist 
        val zipped = zipWith (fn (x,y)=>(x,y)) argsparalist args
        val bind = zipWith Mips.MOVE argsparalist args
        val localVtable = foldl(fn ((x,y),acc)=>SymTab.bind x y acc) (SymTab.empty()) zipped
        val compiledExp = compileExp exp localVtable place
    in []
      @ bind
      @ compiledExp
    end
\end{lstlisting}


    \section{Task 4 - Copy propagation and constant folding}
	For our implementation of the optimizations copy propagration and constant
	folding, we have made additions to \texttt{CopyConstPropFold.sml}, specifically
	we have added cases for variables, \texttt{let}-bindings, multplication,
	division, logical and/or, logical negation and integer negation in function
	\texttt{copyConstPropFoldExp}.
	\subsection{Multiplication}
	Our implementation of the case for multiplication is based on the simplifications
	given for constant folding of multiplication expressions given in \texttt{GroupProj14.pdf}.
	They are as follows, here \texttt{e1'} and \texttt{e2'} are the recursively optimized
	subexpressions, found in a multiplication expression: $ \texttt{e1} \ast \texttt{e2}$
	\begin{itemize}
	\item if \texttt{e1'} and \texttt{e2'} are constant values then the result will be the
			multiplication value,
	\item if \texttt{e1'} (\texttt{e2'}) is value \texttt{1} then the result is \texttt{e2'}
			(\texttt{e1'}) because $\texttt{1} \ast \texttt{e2'} = \texttt{e1'}$,
	\item if \texttt{e1'} (\texttt{e2'}) is value \texttt{0} then the result is constant value
			\texttt{0} because $\texttt{0} \ast \texttt{e2'} = \texttt{0}$,
	\item otherwise the optimsed result is  \texttt{Times (e1', e2', pos)}.
	\end{itemize}
	Based on this we have implemented our optimization case for multiplication expressions like this:
	\begin{lstlisting}
      | Times (e1, e2, pos) =>
        let val e1' = copyConstPropFoldExp vtable e1
            val e2' = copyConstPropFoldExp vtable e2
        in case (e1', e2') of
               (Constant (IntVal x, _), Constant (IntVal y, _)) =>
               Constant (IntVal (x*y), pos)
             | (Constant (IntVal 0, _), _) =>
               Constant (IntVal 0, pos)
             | (_, Constant (IntVal 0, _)) =>
               Constant (IntVal 0, pos)
             | (Constant (IntVal 1, _), _) =>
               e2'
             | (_, Constant (IntVal 1, _)) =>
               e1'
             | _ =>
               Times (e1', e2', pos)
        end
	\end{lstlisting}
	First the subexpressions, \texttt{e1} and \texttt{e2}, of the multiplication expression are
	optimized, and put respectively in variables \texttt{e1'} and \texttt{e2'}.
	Then the cases described above are run through. A similar rationale have been applied to the
	implementation of the case for division. The implementation can be seen in appendix \ref{CopyConstPropFold}.
	\subsection{Logical and}
	For the case of logical and, we have made the following simplificatons, and based our implementation
	on these. Again \texttt{e1'} and \texttt{e2'} are the recursively optimized subexpressions:
	\begin{itemize}
	\item if \texttt{e1'} and \texttt{e2'} are bools, then the result should be
	\texttt{e1'} \texttt{and} \texttt{e2'}
	\item otherwise the optimsed result is  \texttt{And (e1', e2', pos)}.
	\end{itemize}
	Based on this, we have implemented the case for logical and, in the following way:
	\begin{lstlisting}
      | And (e1, e2, pos) =>
        let val e1' = copyConstPropFoldExp vtable e1
            val e2' = copyConstPropFoldExp vtable e2
        in case (e1', e2') of
               (Constant(BoolVal x,_),Constant(BoolVal y,_)) =>
               Constant(BoolVal (x andalso y),pos)
             | _ =>
               And (e1', e2', pos)
        end
	\end{lstlisting}
	First the subexpressions \texttt{e1} and \texttt{e2}, found in the and-expression, are
	optimized, and put respectively in variables \texttt{e1'} and \texttt{e2'}. The cases descriped above
	are then run through. Our implementation of logical or follows a similar rationale, and can be found in
	appendix \ref{CopyConstPropFold}.
	\subsection{Logical not}
	As with multiplication and logical and, we have made some simplifications describing the
	constant folding on logical not, they are as follows:
	\begin{itemize}
	\item if \texttt{e1'} is true then return false,
	\item if \texttt{e1'} is false then return true,
	\item otherwise the optimsed result is  \texttt{Not (e1', pos)}.
	\end{itemize}
	Our implementation has been based on these simplification, it is found below:
	\begin{lstlisting}
      | Not (e1, pos) =>
        let val e1' = copyConstPropFoldExp vtable e1
        in case (e1') of
               Constant (BoolVal true, _) =>
               Constant (BoolVal false, pos)
             | Constant (BoolVal false, _) =>
               Constant (BoolVal true, pos)
             | _ =>
               Not (e1', pos)
        end
	\end{lstlisting}
	First \texttt{e1} is recursively optimised, and put in \texttt{e1'}. The described cases are
	then run through. Our implementation of integer negation follows a similar rationale, and can
	be found in appenddix \ref{CopyConstPropFold}.
	\subsection{Variables}
	For variables we have implemented the following:
	\begin{lstlisting}
      | Var (name, pos) =>
        let val name = name
            val pos = pos
        in case (SymTab.lookup name vtable) of
            SOME (VarProp newname) => Var (newname, pos)
          | SOME (ConstProp value) => Constant (value, pos)
          | _                      => Var (name, pos)
        end
	\end{lstlisting}
	First the given variable is looked up in the \texttt{vtable}. If a new variable name is returned, our
	variable is thus just a copy of that variable, and we return the new variable, i.e copy propagation. If
	on the other hand a constant value is returned, we return that constant, i.e constant propagation.
	Otherwise our variable is returned as it is, i.e no propagation occurs.
	\subsection{\texttt{let}-bindings}
	We use the term propagatee throughout this part. A propagatee is a variable's defining expression. The
	defining expression of a variable is defined to be either a constant value, or another variable. Below is
	our code for \texttt{let}-bindings. Generally this case detects propagatees in the
	\texttt{let}-binding expression and binds them to the vtable. It also optimizes the expression and the
	body of the \texttt{let}-binding.
	\begin{lstlisting}
      | Let (Dec (name, e, decpos), body, pos) =>
        let val e' = copyConstPropFoldExp vtable e
            val vtable' = bindExpPropagatee name e' vtable
            val body' = copyConstPropFoldExp vtable' body
        in Let (Dec (name, e', decpos), body', pos)
        end
	\end{lstlisting}
	Propagatees are detected and bound to the vtable, by calling function \texttt{bindExpPropagatee} on the optimized expression
	\texttt{e'}and the \texttt{vtable}. \texttt{bindExpPropagatee} calls another function \texttt{expPropagatee}, which extracts
	an propagatee from a given expression. If some propagatee is returned from \texttt{expPropagatee}, it is bound to the vtable.
	\begin{lstlisting}
fun expPropagatee (Var (varname, _)) = SOME (VarProp varname)
  | expPropagatee (Constant (value, _)) = SOME (ConstProp value)
  | expPropagatee _ = NONE

fun bindExpPropagatee name e vtable =
    case expPropagatee e of
        NONE => SymTab.remove name vtable
      | SOME prop => SymTab.bind name prop vtable
	\end{lstlisting}

	\subsection{Tests}
	We have tested out optimization implementations by using the commands: \\
	$\backslash \texttt{bin}\backslash \texttt{fasto -p c testfile.fo}$ and
	$\backslash \texttt{bin}\backslash \texttt{fasto -p testfile.fo}$. With \texttt{-p c}, we only test with the constant folding and
	copy/constant propagation pass, whereas with just \texttt{-p}, we run the only set of optimizations. Our first example is found in \texttt{1optim.fo}, here we first test with \texttt{-p c}.\medskip\\
	\begin{center}
	\begin{minipage}{.5\textwidth}
	\begin{lstlisting}
fun int main() =
    let a = read(int) in
    let b =
        let x = a in
        let y = 2 in
        (x + 2) * (y - 2) in
    b

	\end{lstlisting}
	\end{minipage}%
	\begin{minipage}{.1\textwidth}
	$\rightarrow$
	\end{minipage}%
	\begin{minipage}{.4\textwidth}
	\begin{lstlisting}
fun int main() =
    let a = read(int) in
    let b =
        let x = a in
        let y = 2 in
        0 in
    b
	\end{lstlisting}
	\end{minipage}
	\end{center}
	It is clear that the expression \texttt{(x + 2) $\ast$ (y - 2)} has been optimized to zero, as $\texttt{y = 2}$
	and $\texttt{(y-2) = 0}$. Going further with \texttt{-p}, we get:
	\begin{center}
	\begin{minipage}{.5\textwidth}
	\begin{lstlisting}
fun int main() =
    let a = read(int) in
    let b =
        let x = a in
        let y = 2 in
        (x + 2) * (y - 2) in
    b

	\end{lstlisting}
	\end{minipage}%
	\begin{minipage}{.1\textwidth}
	$\rightarrow$
	\end{minipage}%
	\begin{minipage}{.4\textwidth}
	\begin{lstlisting}
fun int main() =
    let a = read(int) in
    let b = 0 in
    b
	\end{lstlisting}
	\end{minipage}
	\end{center}
	Here the dead variables, \texttt{x} and \texttt{y}, have also been removed. \\
    This refers to \ref{app_title}

    \newpage
    \appendix
    \section{Interpreter AND and OR} \label{interpreter_and_and_or}
    \begin{lstlisting}[basicstyle=\small]
| evalExp ( And(e1, e2, pos), vtab, ftab ) =
      let val r1 = evalExp(e1, vtab, ftab)
      in case r1 of
         BoolVal b1 => if b1 then
                        let val r2 = evalExp(e2, vtab, ftab)
                        in case r2 of
                           BoolVal b2 => BoolVal b2
                         | otherwise  => raise Error ("And expect boolval", pos)
                        end
                       else BoolVal b1
       | otherwise  => raise Error ("And expect boolval", pos)
      end

| evalExp ( Or(e1, e2, pos), vtab, ftab ) =
      let val r1 = evalExp(e1, vtab, ftab)
      in case r1 of
         BoolVal b1 => if not b1 then
                        let val r2 = evalExp(e2, vtab, ftab)
                        in case r2 of
                           BoolVal b2 => BoolVal b2
                         | otherwise  => raise Error ("Or expect boolval", pos)
                        end
                       else BoolVal b1
       | otherwise  => raise Error ("Or expect boolval", pos)
      end
    \end{lstlisting}

    \newpage
    \section{Code Generator AND and OR} \label{code_gen_and_and_or}
    \begin{lstlisting}[basicstyle=\small]
| And (e1, e2, pos) =>
    let val falseLabel = newName "falseLabel"
        val endLabel   = newName "endLabel"
        val t1         = newName "and_L"
        val t2         = newName "and_R"
        val code1      = compileExp e1 vtable t1
        val code2      = compileExp e2 vtable t2
    in code1                            @
       [Mips.BEQ (t1, "0", falseLabel)] @
       code2                            @
       [Mips.BEQ (t2, "0", falseLabel)] @
       [Mips.LI (place, "1")]           @
       [Mips.J endLabel]                @
       [Mips.LABEL falseLabel]          @
       [Mips.LI (place, "0")]           @
       [Mips.LABEL endLabel]
     end
| Or (e1, e2, pos) =>
    let val trueLabel = newName "trueLabel"
        val endLabel  = newName "endLabel"
        val t1        = newName "or_L"
        val t2        = newName "or_R"
        val code1     = compileExp e1 vtable t1
        val code2     = compileExp e2 vtable t2
    in code1                           @
       [Mips.BNE (t1, "0", trueLabel)] @
       code2                           @
       [Mips.BNE (t2, "0", trueLabel)] @
       [Mips.LI (place, "0")]          @
       [Mips.J endLabel]               @
       [Mips.LABEL trueLabel]          @
       [Mips.LI (place, "1")]          @
       [Mips.LABEL endLabel]
    end
    \end{lstlisting}

    \newpage
    \section{Interpreter NOT} \label{interpreter_not}
    \begin{lstlisting}[basicstyle=\small]
| evalExp ( Not(e1, pos), vtab, ftab ) =
      let val r1 = evalExp(e1, vtab, ftab)
      in case r1 of
          BoolVal true  => BoolVal false
        | BoolVal false => BoolVal true
        | other         => raise Error("Not expects a boolean value", pos)
      end
    \end{lstlisting}

    \newpage
    \section{Code Generation NOT} \label{code_gen_not}
    \begin{lstlisting}[basicstyle=\small]
| Not (e1, pos) =>
    let val zeroLabel = newName "zeroLabel"
        val endLabel  = newName "endLabel"
        val t1        = newName "not_R"
        val code      = compileExp e1 vtable t1
    in code                            @
       [Mips.BEQ (t1, "0", zeroLabel)] @
       [Mips.XOR (place, t1, t1)]      @
       [Mips.J endLabel]               @
       [Mips.LABEL zeroLabel]          @
       [Mips.LI (place, "1")]          @
       [Mips.LABEL endLabel]
    end
    \end{lstlisting}

    \newpage
    \section{Boolean Implementation} \label{boolean_implementation}
    \subsection{Lexer}
    \begin{lstlisting}[basicstyle=\small]
| "true"         => Parser.BOOLLIT (true, pos)
| "false"        => Parser.BOOLLIT (false, pos)
    \end{lstlisting}

    \subsection{Parser}
    \begin{lstlisting}[basicstyle=\small]
(...)
%token <bool*(int*int)> BOOLLIT
(...)
| BOOLLIT             { Constant (BoolVal (#1 $1), #2 $1) }
    \end{lstlisting}

    \subsection{Interpreter}
    \begin{lstlisting}[basicstyle=\small]
fun evalExp ( Constant (v,_), vtab, ftab ) = v
    \end{lstlisting}

    \subsection{typechecker}
    \begin{lstlisting}[basicstyle=\small]
In.Constant  (v, pos)     => (valueType v, Out.Constant (v, pos))
    \end{lstlisting}

    \subsection{Code Generation}
    \begin{lstlisting}[basicstyle=\small]
| Constant (BoolVal b, pos) => if b
                               then [Mips.LI (place, "1")]
                               else [Mips.LI (place, "0")]
    \end{lstlisting}

    \section{Task 1 Tests} \label{task_1_tests}
    \subsection{and\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun bool main() =
    true && '5'
    \end{lstlisting}

    \subsection{andOr.fo}
    \begin{lstlisting}[basicstyle=\small]
fun [char] writebool(bool b) = if b then write("true") else write("false")

fun int main() =
    let a = 1 == 1 in        // a = true
    let b = 1 == 2 in        // a = false
    let c = a || b && a in   // c = true
    let d = a && b in        // d = false
    let e = a || b in        // e = true
    let f = (a || b) && b in // f = false
    let w = writebool(a) in
    let w = writebool(b) in
    let w = writebool(c) in
    let w = writebool(d) in
    let w = writebool(e) in
    let w = writebool(f) in
        0
    \end{lstlisting}

    \subsection{and\_sc.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    let a = {true, false, true, true, true, false} in
        if false && a[100] // Array index out of bounds
        then write(1)
        else write(0)
    \end{lstlisting}

    \subsection{boolCompare.fo}
    \begin{lstlisting}[basicstyle=\small]
fun [char] printbool(bool b) = if b then write("true ") else write("false ")

fun int main() =
    let False = false in
    let True = true in
    let w = printbool(False) in // false
    let w = printbool(True) in // true
    let w = printbool(True == True) in // true
    let w = printbool(True == False) in // false
    let w = printbool(True == False || not False == True) in // true
    let w = printbool(1+2 == 2) in // false
    let w = printbool(10*2 == 20 ) in // true
    let w = printbool(10/2 == 5 ) in // true
    let w = printbool(False == True || not False && True == false) in // false
        0
    \end{lstlisting}

    \subsection{boolLit.fo}
    \begin{lstlisting}[basicstyle=\small]
fun [char] writebool(bool b) = if b then write("true") else write("false")

fun int main() =
    let a = true in
    let b = false in
    let w = writebool(a) in
    let w = writebool(b) in
        0
    \end{lstlisting}

    \subsection{div\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    4 / 'h'
    \end{lstlisting}

    \subsection{intNegate.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int test(int x) =
    let w = write (x)  in
    0

fun int main() =
    let w =  test(3/2) in
    let w =  test(5/3) in
    let w =  test(10/9) in
    let w =  test(10/11) in
    let w =  test(~10/2) in
    let w =  test(~10/~2) in
    let w =  test(10/~2) in
    let w =  test(5/~3) in
    let w =  test(1+2+5/3*9+3) in
    let w =  test(5+10/~2*3-~2) in //(5+((5/(-2))*3))-(-3)= -1.5 ~~ -1

    0
    \end{lstlisting}

    \subsection{muldivide.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    let q = 3*5 in
    let w = 4/2 in
    let r = 5/2 in
    let g = write(q) in
    let g = write(w) in
    let g = write(r) in
    0
    \end{lstlisting}

    \subsection{mul\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    4 * 'h'
    \end{lstlisting}

    \subsection{negate2.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    let w = write(~2 * 4) in
    let w = write(2 * 4) in
    let w = write(~2 - ~2) in
    let w = write(~5 + 5) in
        0
    \end{lstlisting}

    \subsection{negate.fo}
    \begin{lstlisting}[basicstyle=\small]
fun bool main() =
    let x0 =  write(3 / 2 ==  1) in
    let x1 = write(~3 / 2 == ~2) in
    let x2 =  write(3 /~2 == ~2) in
    let x3 = write(~3 /~2 ==  1) in
    let x4 = write(~(5+5) ==  ~10) in
    let x5 = write(~(5+5)) in
    let x5 = write(~(1)) in
    write(x0 && x1 && x2 && x3 && x4)
    \end{lstlisting}

    \subsection{neg\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun int main() =
    let a = 5 in
    let b = 'h' in
    ~a + ~b
    \end{lstlisting}

    \subsection{not\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun bool main() =
    if not 'h' then true else false
    \end{lstlisting}

    \subsection{or\_err.fo}
    \begin{lstlisting}[basicstyle=\small]
fun bool main() =
    false || false || {'h', 'e', 'j'}
    \end{lstlisting}

    \subsection{or\_sc.fo}
    \begin{lstlisting}[basicstyle=\small]

    \end{lstlisting}

\end{document}
