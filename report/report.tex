\documentclass[11pt]{article}
\usepackage[a4paper, hmargin={2.8cm, 2.8cm}, vmargin={2.5cm, 2.5cm}]{geometry}
\usepackage{eso-pic} % \AddToShipoutPicture
\usepackage{graphicx} % \includegraphics
\usepackage{fancyhdr, amsmath, amssymb, comment, caption, placeins, subfigure,
    fixltx2e, changepage, listings, courier, soul, hyperref, geometry,
    enumerate, dsfont, listings, enumitem}
    \usepackage[T1]{fontenc}

\author{\Large{Magnus N\o rskov Stavngaard} \\ 
		\texttt{magnus@stavngaard.dk}
		\\\\
		\Large{Mark Jan Jacobi} \\
        \texttt{mark@jacobi.pm}		
		 \\\\
		\Large{Christian Salb\ae k} \\
		\texttt{chr.salbaek@gmail.com}		
} 

\title{
    \vspace{3cm}
    \Huge{Compiler Design} \\
    \Large{Compiler for the Fasto Programming Language}
}

\pagestyle{fancy}
\lhead{\small{Magnus N. S. Mark J. J. Christian S.}}
\chead{\date{\today}}
\rhead{University of Copenhagen}
% \lfoot{}
% \cfoot{}
% \rfoot{}

% Change indent length of paragraph not after a header.
\setlength{\parindent}{0cm}

% Remove page numbering in the beginning
\pagenumbering{gobble}

\begin{document}

    %% Change `ku-farve` to `nat-farve` to use SCIENCE's old colors or
    %% `natbio-farve` to use SCIENCE's new colors and logo.
    \AddToShipoutPicture*{\put(0,0){\includegraphics*[viewport=0 0 700 600]
        {include/ku-farve}}}
    \AddToShipoutPicture*{\put(0,602){\includegraphics*[viewport=0 600 700 1600]
        {include/ku-farve}}}

    %% Change `ku-en` to `nat-en` to use the `Faculty of Science` header
    \AddToShipoutPicture*{\put(0,0){\includegraphics*{include/ku-en}}}

    \clearpage
    \maketitle
    \thispagestyle{empty}

    \newpage

    \pagenumbering{arabic} % Arabic page numbers (and reset to 1)

    \section{Task 1 - Warmup}
    In task 1 we were asked to implement the boolean operators \texttt{\&\&},
    \texttt{||} and \texttt{not}, the boolean constants true and false, integer
    multiplication, integer division and integer negation. \\

    We will go through in detail the implementation of integer division and
    multiplication and then skip rather quickly over the implementation of the
    rest of the operators only describing what is different from multiplication
    and division as the operations is implemented very similar.

    \subsection{Integer Multiplication and Division}
    We started by implementing integer multiplication and division in the Lexer.
    We created a new rule for the star and division operator that created tokens
    and passed the tokens to the parser.

    \begin{lstlisting}[basicstyle=\small]
| `*`   { Parser.TIMES    (getPos lexbuf) }
| `/`   { Parser.DIVIDE   (getPos lexbuf) }
    \end{lstlisting}

    In the parser we added the tokens where addition and subtraction was already
    defined, as integer multiplication and division has allot in common with
    addition and subtraction.  Integer multiplication and division carries two
    integers corresponding to a position in the code.

    \begin{lstlisting}[basicstyle=\small]
%token <(int*int)> PLUS MINUS TIMES DIVIDE DEQ EQ LTH BOOLAND BOOLOR NOT NEG
    \end{lstlisting}

    We also declare both times and divide as left associative operators with
    greater precedence than addition and subtraction.

    \begin{lstlisting}[basicstyle=\small]
%left BOOLOR
%left BOOLAND
%left NOT
%left DEQ LTH
%left PLUS MINUS
%left TIMES
%left DIVIDE
%left NEG
    \end{lstlisting}

    We then defined that an expression could consist of an expression followed
    by a multiplication or division followed by an expression.  And that this
    correspond to \texttt{Times} and \texttt{Divide} in the Fasto language
    definition.

    \begin{lstlisting}[basicstyle=\small]
Exp :     NUM                 { Constant (IntVal (#1 $1), #2 $1) }
        | CHARLIT             { Constant (CharVal (#1 $1), #2 $1) }

        (...)

        | Exp TIMES Exp       { Times($1, $3, $2) }
        | Exp DIVIDE Exp      { Divide($1, $3, $2) }

        (...)
    \end{lstlisting}

    In the interpreter we implemented cases for \texttt{Times} and
    \texttt{Divide} in the \texttt{evalExpr} function.

    \begin{lstlisting}[basicstyle=\small]
| evalExp ( Times(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op *, res1, res2, pos)
      end

| evalExp ( Divide(e1, e2, pos), vtab, ftab ) =
      let val res1 = evalExp(e1, vtab, ftab)
          val res2 = evalExp(e2, vtab, ftab)
      in  evalBinopNum(op Int.quot, res1, res2, pos)
      end
    \end{lstlisting}

    Our cases evaluate recursively the expressions to the left and right of the
    operator and then calls \texttt{evalBinopNum} with the appropriate operator
    and the results from evaluating the lefthand and the righthand side of the
    expression. \\

    We then implemented the operators in the typechecker.  Our cases call a
    helper function \texttt{checkBinOp} that takes a position, an expected type,
    and two expressions and check that the two expressions have the type of the
    expected type.  If the types match the types is returned with
    \textit{typedecorated} versions of the expressions, if the types doesn't
    match an error is raised. \\
    We then simply return the same operation, now with a return type.

    \begin{lstlisting}[basicstyle=\small]
| In.Times (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Times (e1_dec, e2_dec, pos))
     end

| In.Divide (e1, e2, pos)
  => let val (_, e1_dec, e2_dec) = checkBinOp ftab vtab (pos, Int, e1, e2)
     in (Int, Out.Divide (e1_dec, e2_dec, pos))
     end
    \end{lstlisting}

    We can now finally implement the operators in the code generator.  Here we
    create two temporary variables \texttt{t1} and \texttt{t2} to hold the
    values of the expression on either side of the operator.  We then call the
    function \texttt{compileExp} recursively with these names to get the machine
    code for the expression on either side of the operator.  Then we just simply
    return a list of first the code to compute the left hand side of the
    operator, then the right hand side, and then we apply the MIPS commands
    \texttt{MUL} and \texttt{DIV} to the two \textit{subresults} and save the
    result in \texttt{place}.

    \begin{lstlisting}[basicstyle=\small]
| Times (e1, e2, pos) =>
    let val t1 = newName "times_L"
        val t2 = newName "times_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.MUL (place, t1, t2)]
    end
| Divide (e1, e2, pos) =>
    let val t1 = newName "divide_L"
        val t2 = newName "divide_R"
        val code1 = compileExp e1 vtable t1
        val code2 = compileExp e2 vtable t2
    in  code1 @ code2 @ [Mips.DIV (place, t1, t2)]
    end
    \end{lstlisting}

    \subsection{Boolean Operators}
    We started by implementing the boolean operators in the lexer in a very
    similar way that we implemented multiplication and division.  In the parser,
    we made sure that the boolean operators were defined as having a lower
    precedence than the arithmetic operators, so that an expression like,

    \begin{lstlisting}[basicstyle=\small]
        2 + 4 == 6 || 5 + 8 == 10 && 8 < 10
    \end{lstlisting}

    is evaluated like,

    \begin{lstlisting}[basicstyle=\small]
        (2 + 4 == 6) || ((5 + 8 == 10) && (8 < 10)).
    \end{lstlisting}

    Notice that the \texttt{\&\&} operator is also evaluated before the
    \texttt{||} operator. \\

    After this we implemented the operators in the interpreter.  Here we created
    two new functions \texttt{evalAnd} and \texttt{evalOr} which evaluated and
    and or operations and returned an error if the expression to the left or
    right of the operators didn't return a boolean value.

    \begin{lstlisting}[basicstyle=\small]
fun evalAnd (BoolVal e1, BoolVal e2, pos) = BoolVal (e1 andalso e2)
  | evalAnd (e1, e2, pos) = raise Error("&& expects bool operands", pos)

fun evalOr (BoolVal e1, BoolVal e2, pos) = BoolVal (e1 orelse e2)
  | evalOr (e1, e2, pos) = raise Error("|| expects bool operands", pos)
    \end{lstlisting}

    We evaluated the expressions to the left and right of the operator and then
    called the helper functions afterwards. \\

    In the code generator it was required that we implemented the boolean
    operators to be short-circuiting so that the right hand side of an and only
    evaluates if the left hand side is true. Similarly the right hand side of an
    or evaluates only if the left hand side is false.  We did this with the MIPS
    assembly code,

    \begin{lstlisting}[basicstyle=\small]
;; Code computing the left hand side of an and, and saving result to $t1

beq $t1, $zero, False

;; Code computing the right hand side of an and, and saving the result to $t2

beq $t2, $zero, False
li  $s1, 1 ;; Assuming the result should be saved to $s1
j   End

False:
    li  $s1, 0 ;; Assuming the result should be saved to $s2

End:
    \end{lstlisting}

    It can be seen that if the first part of an and return false i.e. the
    result register contains 0, we simply skip over the execution of the right
    hand side and jump strait to False.  We did something similar for or's.

    \section{Task 2 - Implement \texttt{filter} and \texttt{scan}}
    \subsection{Typerules}
    The typerules for \texttt{filter} and \texttt{scan} have been based on the
    already existing typerules for \texttt{map} and \texttt{reduce}. They are as
    follows: \\

    \texttt{filter}: ($\alpha \rightarrow$ bool) $\ast$ $[\alpha]$ $\rightarrow$
    $[\alpha]$, typerule for \texttt{filter(f, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item compute t, the type of x and check that $\text{t} =
            [\text{t}_\text{e}]$ for some type $\text{t}_\text{e}$
        \item get f's signature from \texttt{ftable}. \texttt{IF} f does not
            receive exactly one argument \texttt{THEN} return \texttt{error()}
            \texttt{ELSE} $\text{f: t}_{\text{in}} \rightarrow
            \text{t}_{\text{out}}$ for some types $\text{t}_{\text{in}}$ and
            $\text{t}_{\text{out}}$.
        \item \texttt{IF} $\text{t}_{\text{in}} = \text{t}_\text{e}$
            \texttt{AND} $\text{t}_{\text{out}} = \texttt{bool}$ \texttt{THEN
            filter(f, x) ELSE error()}.
    \end{itemize}

    \texttt{scan}: ($\alpha \ast \alpha \rightarrow \alpha$) $\ast$ $\alpha$
    $\ast$ [$\alpha$] $\rightarrow$ [$\alpha$], typerule for
    \texttt{scan(f, e, x)}:
    \vspace{-2.5mm}
    \begin{itemize}[noitemsep]
        \item Compute t, the type of e and $\text{t}_\text{x}$, the type of x
            and check that:
        	\begin{enumerate}[noitemsep]
        	   \item f: (t $\ast$ t) $\rightarrow$ t
        	   \item $\text{t}_\text{x} = [\text{t}]$
    		\end{enumerate}
        \item If so then \texttt{scan(f, e, x)}
    \end{itemize}

    \section{$\lambda$-expressions in SOAC's}
    We implemented lambda functions in the lexer by creating a keyword
    \texttt{fn} corresponding to a \texttt{LAMBDA} in the parser.  We also
    created a token for the special equals symbols used in lambda expressions
    (=$>$).  We called this token \texttt{LAMBDAEQ}.  We then implemented lambdas
    in the parser.  We did this by observing that the \texttt{map} function in
    the parser is defined as,

    \begin{lstlisting}[basicstyle=\small]
| MAP LPAR FunArg COMMA Exp RPAR { Map ($3, $5, (), (), $1) }
    \end{lstlisting}

    meaning that the lambda is supposed to passed as a \texttt{FunArg}.  We then
    looked at the declaration of a FunArg,

    \begin{lstlisting}[basicstyle=\small]
FunArg : ID { FunName (#1 $1) },
    \end{lstlisting}

    and added to this definition a case for a lambda function.  In Fasto a
    \texttt{FunArg} is defined as,

    \begin{lstlisting}[basicstyle=\small]
and FunArg = Lambda of Type * Param list * Exp * pos
           | FunName of string.
    \end{lstlisting}

    We then just took the syntax of a lambda and translated that to a list of
    tokens.  Then we pattern matched on that expression and transfered the
    values needed by the lambda in Fasto.

    \begin{lstlisting}[basicstyle=\small]
FunArg : ID { FunName (#1 $1) }
     |   LAMBDA Type LPAR Params RPAR LAMBDAEQ Exp { Lambda ($2, $4, $7, $1) }
    \end{lstlisting}

    We implemented lambdas in the interpreter by changing the way function
    arguments are evaluated.  We could do this as it is an invariant of the
    Fasto programming language that lambdas can only be used in Second Order
    Array Constructors (SOAC's).  We simply matched a case where
    \texttt{evalFunArg} is called with a lambda instead of a function name.  We
    then use this lambda to construct a function definition with the generic
    name \textit{lambda}.  We then call \texttt{callFunWithVtable} with this
    function declaration and the vtable passed to the function, this means that
    we keep the binding between local variable names and their values and the
    lambda can use these variables.  The function returns an anonymous function
    in sml that takes an argument list and applies the lambda to those
    arguments.

    \begin{lstlisting}[basicstyle=\small]
and evalFunArg (FunName fid, vtab, ftab, callpos) =
    let
      val fexp = SymTab.lookup fid ftab
    in
      case fexp of
        NONE   => raise Error("Function "^fid^" is not in SymTab!", callpos)
      | SOME f => (fn aargs => callFun(f, aargs, ftab, callpos), getFunRTP f)
    end
  | evalFunArg (Lambda (tp, paralist, exp, pos), vtab, ftab, pcall) =
    let val fexp = FunDec ("lambda", tp, paralist, exp, pos)
    in (fn aargs => callFunWithVtable(fexp, aargs, vtab, ftab, pcall), tp)
    end
    \end{lstlisting}
    
    \section{Copy propagation and constant folding}
	For our implementation of the optimizations copy propagration and constant
	folding, we have made additions to \texttt{CopyConstPropFold.sml}, specifically
	we have added cases for variables, \texttt{let}-bindings, multplication,
	division, logical and/or, logical negation and integer negation in function
	\texttt{copyConstPropFoldExp}.
	\subsection{Multiplication}
	Our implementation of the case for multiplication is based on the simplifications
	given for constant folding of multiplication expressions given in \texttt{GroupProj14.pdf}.
	They are as follows, here \texttt{e1'} and \texttt{e2'} are the recursively optimized
	subexpressions, found in a multiplication expression: $ \texttt{e1} \ast \texttt{e2}$ 
	\begin{itemize}
	\item if \texttt{e1'} and \texttt{e2'} are constant values then the result will be the
			multiplication value,
	\item if \texttt{e1'} (\texttt{e2'}) is value \texttt{1} then the result is \texttt{e2'}
			(\texttt{e1'}) because $\texttt{1} \ast \texttt{e2'} = \texttt{e1'}$,
	\item if \texttt{e1'} (\texttt{e2'}) is value \texttt{0} then the result is constant value
			\texttt{0} because $\texttt{0} \ast \texttt{e2'} = \texttt{0}$,
	\item otherwise the optimsed result is  \texttt{Times (e1', e2', pos)}.
	\end{itemize}
	Based on this we have implemented our optimization case for multiplication expressions like this:
	\begin{lstlisting}
      | Times (e1, e2, pos) =>
        let val e1' = copyConstPropFoldExp vtable e1
            val e2' = copyConstPropFoldExp vtable e2
        in case (e1', e2') of
               (Constant (IntVal x, _), Constant (IntVal y, _)) =>
               Constant (IntVal (x*y), pos)
             | (Constant (IntVal 0, _), _) =>
               Constant (IntVal 0, pos)
             | (_, Constant (IntVal 0, _)) =>
               Constant (IntVal 0, pos)
             | (Constant (IntVal 1, _), _) =>
               e2'
             | (_, Constant (IntVal 1, _)) =>
               e1'
             | _ =>
               Times (e1', e2', pos)
        end
	\end{lstlisting}
	First the subexpressions, \texttt{e1} and \texttt{e2}, of the multiplication expression are
	optimized, and put respectively in variables \texttt{e1'} and \texttt{e2'}.
	Then the cases described above are run through. A similar rationale have been applied to the
	implementation of the cases for division, logical and/or, logical negation and integer negation.
	Their implementation can be seen in appendix ?.
	\subsection{Variables}
	For variables we have implemented the following:
	\begin{lstlisting}
      | Var (name, pos) =>
        let val name = name
            val pos = pos
        in case (SymTab.lookup name vtable) of
            SOME (VarProp newname) => Var (newname, pos)
          | SOME (ConstProp value) => Constant (value, pos)
          | _                      => Var (name, pos)
        end
	\end{lstlisting}
	First the given variable is looked up in the \texttt{vtable}. If a new variable name is returned, our
	variable is thus just a copy of that variable, and we return the new variable, i.e copy propagation. If
	on the other hand a constant value is returned, we return that constant, i.e constant propagation.
	Otherwise our variable is returned as it is, i.e no propagation occurs.
	\subsection{\texttt{let}-bindings}
	We use the term propagatee throughout this part. A propagatee is a variable's defining expression. The
	defining expression of a variable is defined to be either a constant value, or another variable. Below is
	our code for \texttt{let}-bindings. Generally this case detects propagatees in the
	\texttt{let}-binding expression and binds them to the vtable. It also optimizes the expression and the
	body of the \texttt{let}-binding.
	\begin{lstlisting}
      | Let (Dec (name, e, decpos), body, pos) =>
        let val e' = copyConstPropFoldExp vtable e
            val vtable' = bindExpPropagatee name e' vtable
            val body' = copyConstPropFoldExp vtable' body
        in Let (Dec (name, e', decpos), body', pos)
        end
	\end{lstlisting}
	Propagatees are detected and bound to the vtable, by calling function \texttt{bindExpPropagatee} on the optimized expression
	\texttt{e'}and the \texttt{vtable}. \texttt{bindExpPropagatee} calls another function \texttt{expPropagatee}, which extracts
	an propagatee from a given expression. If some propagatee is returned from \texttt{expPropagatee}, it is bound to the vtable.
	\begin{lstlisting}
fun expPropagatee (Var (varname, _)) = SOME (VarProp varname)
  | expPropagatee (Constant (value, _)) = SOME (ConstProp value)
  | expPropagatee _ = NONE	
	
fun bindExpPropagatee name e vtable =
    case expPropagatee e of
        NONE => SymTab.remove name vtable
      | SOME prop => SymTab.bind name prop vtable
	\end{lstlisting}
\end{document}
